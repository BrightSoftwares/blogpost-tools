---
author: full
categories:
- kubernetes
date: 2023-02-01
description: Ovehttps://www.digitalocean.com/community/cheatsheets/getting-started-with-kubernetes-a-kubectl-cheat-sheet
image: https://res.cloudinary.com/brightsoftwares/image/upload/t_BSBlogImage/v1655551333/pexels-martin-dalsgaard-11279594_p4iavf.jpg
lang: en
layout: flexstart-blog-single
post_date: 2023-02-01
pretified: true
tags: []
title: Overview on kubectl
transcribed: true
youtube_video: https://www.youtube.com/watch?v=cC46cg5FFAM&ab_channel=GoogleCloudTech
youtube_video_id: cC46cg5FFAM
---

Kubernetes. I hear everyone has been talking about it and you've probably heard of it too. It's become pretty popular and I think it's time to learn what it is. With a whole universe of things to learn, it's important to start with the essentials. let's go over the concepts that make Kubernetes usable, scalable, and just downright awesome. Are you ready? Hey Caslin, good to see you! I was just going over what Kubernetes is That sounds like fun. Kubernetes is a portable, extensible open source platform for managing containerized workloads and services that facilitates both declarative configuration and automation, letting you run distributed systems resiliently with scaling and failover for your application. Okay, well, uh, that's a lot. Do you have a way to simplify that? Good call. Basically, it's a container orchestrator that helps make sure that each container is where it's supposed to be and that the containers can work together. Oh yeah, that makes me think of a conductor that manages everything in an orchestra. You know, are the horns going? Oh the drums? They should be going now, exactly. There's a lot of moving points in a scalable application. just like a conductor makes sure the song sounds like a composer wants. Kubernetes, make sure services are running smoothly the way an app developer wants. Okay, before we get into more details about the what, let's go over why it was created. See, there are a lot of applications that we call monoliths, which means they put all the functionality like transactions, third party integration into a single deployable artifact, and monoliths are a common way to build applications. even today, but they still have their downfalls. For example, deployments can take a long time since everything has to roll out all together, and if different parts of the monolith are managed by different teams, there could be a lot of additional complexity when prepping for a rollout, and scaling has the same problem. Teams have to throw resources at the whole application, even if the bottleneck is only on a single area, right? So, people came up with microservices. Each piece of functionality is split apart into smaller, individual artifacts. If there's an update, only that exact service has to be replaced, and the microservice model has scaling benefits, too. Now, individual services can be scaled to match their traffic, so it's easier to avoid bottlenecks without over provisioning. This is all great, but having one machine for each service would require a lot of resources and a whole bunch of machines. That's why containers are the perfect choice. With containers, teams can package up their services neatly. all the applications, their dependencies, and any necessary configuration get delivered together. This also means that they can be sure their services will run the same way no matter where they're run, but there's still more problems that remain unsolved. Upgrading a container is easy since you can create a new version of the container and deploy it in place of the old one. But how can upgrades be done without downtime? How do these containers know how to talk to the other ones? And how can the app developer debug issues and observe what's happening? And now we've come back to the conductor of our container orchestra. Kubernetes is all about managing these containers on virtual machines or nodes. The nodes in the containers they run are grouped together as a cluster, and each container has endpoints dns, storage, and scalability. Everything that modern applications need without the manual effort of doing it yourself. Kubernetes automates most of the repetition and inefficiencies of doing everything by hand. The app developer tells Kubernetes what it wants the cluster to look like and Kubernetes makes it happen. See, this All sounds amazing, so everyone should just switch to Kubernetes. Yeah, well, not so fast. Microservices still have their own unique challenges, and sometimes a monolith can be the right solution based on what's right for the application itself. And monoliths can still run on Kubernetes even though they won't be able to use all the same benefits. Hmm. Either way, how do you know when you're ready to get started with Kubernetes? Well, the first step is to start using containers. That's easier said than done, but let's save that for the next episode. Okay, so now we have an idea of what kinds of problems Kubernetes helps with, and we've also got an orbital view of what it actually does. Yep, next time let's dig into containers containers, huh? Okay, stay tuned everybody. If you want to get hands on, check out the link in the description and if you enjoyed the episode, subscribe for more.