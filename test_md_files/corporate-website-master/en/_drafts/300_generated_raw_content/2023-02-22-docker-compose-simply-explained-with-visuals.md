---
date: 2023-02-22
description: In the first video, we learned that an image is a template for the environment
  that you want to run, and when you run an image, you get a container. We tried this
  out by running a PHP image. This was okay for our very simple application, but imagine,
  if you have something more complicated, let's work through an example. Traditionally,
  a big website like an online store would be one big application, but a newer trend
  is to split these big applications up into smaller micro-services The website can
  then be quite minimal and it just makes calls to other services to get information
  or to ask them to do some piece of work. We're going to build a really simple ecommerce
  website, but we're going to put the codes that provides the product and the product
  information in its own microservice. The website will then use an api on the product
  service to request the list of
image: https://res.cloudinary.com/brightsoftwares/image/upload/t_BSBlogImage/v1655551310/pexels-elevate-1267338_viff5b.jpg
lang: en
post_date: 2023-02-22
pretified: true
seo:
  links:
  - https://m.wikidata.org/wiki/Q15206305
tags: []
title: Docker compose simply explained (with visuals)
transcribed: true
youtube_video: https://www.youtube.com/watch?v=Qw9zlE3t8Ko&ab_channel=JakeWright
youtube_video_id: Qw9zlE3t8Ko
---

In the first video, we learned that an image is a template for the environment that you want to run, and when you run an image, you get a container. We tried this out by running a PHP image. This was okay for our very simple application, but imagine, if you have something more complicated, let's work through an example. Traditionally, a big website like an online store would be one big application, but a newer trend is to split these big applications up into smaller micro-services The website can then be quite minimal and it just makes calls to other services to get information or to ask them to do some piece of work. We're going to build a really simple ecommerce website, but we're going to put the codes that provides the product and the product information in its own microservice. The website will then use an api on the product service to request the list of products to show to the customer. Something I touched on at the end of the last video is how you should only have one process per container. So each container should provide a single service. So this will want one container running the website and one container running the product service. They should be independent. This means that there can be written in different languages, but they do need to be able to talk to each other, but we'll get to that bit later. Let's start with a product service. I'm going to build this using Python I'm going to create a new directory for this service called product and then here I'm going to write a very simple Python script I'll call it API dot EU I Remember this is another Python tutorial so this is going to be a very quick example. so this is going to be the product. Service: I Want this to be a simple restful api, so I'm going to import flask and flask restful and instantiate these objects. Then I'm going to have a product class which extends resource and this is just going to have a get method which will return some Jason. So we want to sell some ice cream, some chocolates and we'll be healthy and sell some fruit as well. I'm going to add the routine at the bottom and then finally just some code to run the application. Listening on port 80 with debug turned on. obviously a real API would return a lot more data than this. It would be a lot more false out and a lot better in general. but this will since I've use flasks and flasks Westphall I'm going to add these to a requirements txt file so this is a list of dependencies. Pip can then use this file to install everything. This is not specific to docker, this is just a Python thing. But now let's get this running in a docker container first. I'm going to make a docker file remembering back to the previous video. The first line needs to use the Frog keyword to specify a base image that will then build on top of. there is an official Python image that we can use. We just want the latest version of Python and you'll notice it has these on build tags. It explains further down the page that these ones automatically install requirements from the requirements Txt file. It sounds very useful for us. It's as if I planned it in advance. so let's put this in our Docs well from Python : and the tag 3 on Build. Next, we want to copy the source code into the image so we just want to copy the current directory into slash User slash Source Flush up I've chosen user slash so flush up because this is what the on Build image expects. Then we need to give this a command to run when it starts I'm using the command keyword and then this weird array like syntax. we can tell it to run Python and any subsequent elements in this array are arguments passed to Python so we can just tell it to run the script API py So we already know how to run this. Using docker, we do docker bills to create an image out of the steps defined in the docker file and then we do docker run and add some various arguments to specify ports and mount volumes. But you might find us get a bit tedious and as we have more containers running more of our services building in 2000 each one separately and making sure that can communicate is just a pain. This is where Dr. Campos comes in. Dr. Campos lets us define all of our services in a configuration file and with one command. it'll spin up all the containers that we need. The first thing we want to do is make a file called Docker Compose and I'm going to do this one directory up because this is going to cover all of our services so wants to be called Docker - Compose and - Yamo File. So the extension is why MPL in this file. we start by specifying in the version of the composed file format. We do Version : and we're going to go with three. Dr. has changed a lot in the last few years and to keep changing the way Compose files have to be written so this doesn't relate directly to the version of Dr.. Compose that you have installed. This is just a version of the Dr. Campos file format that you wish to write in. The latest version right now is three. There are several differences between each version. There's no reason not to use the latest one. After this, we specify our services or services : and we'll start with a product service. so we give the name. It can be anything you want. First we tell Dr.. Campos what to build. So we use the builds property and we give it a directory containing the doctor compost files. So the folder is called product. We can see here that we've got the folder called product next to Dr.. Campos dot ynl. The directories are relative to where the docker compose file is. next. We can serve our volumes and this is done as a list so you have as many as you want to the format - - then a space and then the directory on the host. so your computer. so product and we want to mount that in slash user slash soul / app. So of course the image when it's built will already have the call inside. but mounting a volume makes development easier because it'll see live code changes as they happen. We can do the same with ports. Another list. Our application is listening on port 80 so we want to map something to pull 80 so to the port on the host will use 5,000 won. This can be anything you could method support AC but it might clash with a webserver already installed on your operating system or something else using port AC Easier to avoid. This will go for 5,000 won and connect that to port AC in the container and that's all we need. This is the stuff that we would have previously specified in the docker run command, but in a much easier format unsaved in a configuration file. To run this, we go back to the terminal and type docker - composed up. You obviously want docker to be running already I'm assuming you have dock of a mask or dock for windows installed and that app is already open. and long as we're in the same directory as the Dr. Campos file, it will automatically start the services. It'll build the images if necessary. In this case, it's going to download that Python image we found on the docker hub. The on-bill trigger will run here automatically and install our flask dependencies. and then finally it'll run our container. So if we go to our browser, we can go to Localhost 5001. It works! It gives us our JSON array of products if we make a change to the product service. Let's say we also sold eggs because we've got the volume mounted Python sees the change. It detects this and reloads. So now when we refresh, we get eggs as well. Ok, we can press control C in the terminal to sell for that container. Now we want to build a website which will use this product service. So make a new folder called website I'm going to write this in PHP Again, it's going to be very quick and simple. We make a file called Index.php We'll add a little bit of HTML What I want to retrieve here is a bullet Point list where each element in the list is a products from the product service. So let's open PHP tags and I can use this function called file Get Contents. I wouldn't recommend this in production, but it works For an example, this function you give it a URL and a return the string containing the contents of whatever is asked that URL Now we get to the interesting question of which URL to use When we access the product service locally, we can use Localhost Call on 5001. This won't work within a docker container because for the container localhost, we'll be itself conveniently for us. Docker Compose creates a virtual network for all of the containers, so by default, each container can access all of the others defined in the compose file and their host names much the service name which is nice. so we call that product - Service. This is the hostname that we can use in our PHP script so we can do HTTP colon slash slash product service. and when we use Docker Compose to run this that will resolve to the product Service container so delegation will contain that role written straight from the product service, We can decode it. Then we can pull the products out of it and loop through them under echo each one a a bullet point list item. For this, we could write a docker file again, but instead I'm going to demonstrate another way to use Docker Compose. We're going to make a new service called website and instead of specifying a directory to build with a Docx file inside, we can just use the image property and give it a name of an image so this could be an image we've built previously ourselves. or it can be an image straight from the docker hub. From the previous tutorial, we know that there's a PHP image that we can use and we want the version that comes with Apache Next, we want volume. So with the product service, this was just for convenience because we made a custom image which included the source code. this time we're getting the image straight from the docker hub so it's not going to include our source code. So we need the volume here for anything to happen. So here we want the website folder to go in slash var slash www slash HTML Again, this is just dependent on the image that you use PHP expects or to exist in that directory. Again, we can do Pulse for five thousand two months to port AC And finally we can use the depends on the property. So we know that the website's not going to work unless the product service is running that called a file get contents which has failed. So we can tell Docker Compose that the website depends on the product service so just uses this name. here. You can list multiple things that a service depends on. So now when we do docker compose up, it's going to pull up here to the image. Then Ill saw the product service. Then it will start the website. So when we go to localhost 5,000 it doesn't work. What's gone wrong? We need to pluralize products now when we refresh. welcome to my shop! Then the PHP script Made a call for the product service, decoded the duration and it displays it on the page. We can see how easy it is to start all of these services and have them communicate. It's all defined in this config file which is easy to change and saved alongside the code so you could commit this to Github for example. Then anyone else who works on the project just has to run Docker Compose up and everything will happen automatically. They don't have to go to any effort to configure a Dev environment. Another feature of Docker Compose is detached mold. You can do docker Compose up - Dee and this will run it in the background so I can continue to do work. We can type docker PS to see that those containers are running. so we've got the the PHP one and the product/service one running now. This also shows us that the PHP image is unmodified straight from the docker hub, whereas the product service is using our custom image which it is named Tutorial Underscore Product service. You obviously can't do Ctrl C any more to stop them, but you can do Docker Compose stop I Hope you see the power of Docker Compose and I hope that this helps you out when running docker Containers. If you've got any questions or feedback, please do leave a comment if this was useful I'd Really appreciate a like and if you want to see more of this then do subscribe. In a future video, we'll look at docker deployment options. Thanks for watching.